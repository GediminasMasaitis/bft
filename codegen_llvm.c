#include <stdio.h>
#include <stdlib.h>

#include "bft.h"

static int label_counter = 0;

static const i32 use_shift_and_mask = 1;

static int get_shift(const int n) {
  if (!use_shift_and_mask) {
    return -1;
  }

  if (n < 2) {
    return -1;
  }

  if ((n & (n - 1)) != 0) {
    return -1;
  }

  i32 shift = 0;
  while ((1 << shift) < n) {
    shift++;
  }

  return shift;
}

static void emit_prologue(FILE *output) {
  fprintf(output, "; LLVM IR generated by bft\n");
  fprintf(output, "target triple = \"x86_64-pc-linux-gnu\"\n\n");

  /* Global cells array */
  fprintf(output, "@cells = global [%d x i8] zeroinitializer, align 16\n\n",
          CELL_COUNT * 2);

  /* External function declarations */
  fprintf(output, "declare i32 @putchar(i32) nounwind\n");
  fprintf(output, "declare i32 @getchar() nounwind\n");
  fprintf(output, "declare ptr @memset(ptr, i32, i64) nounwind\n\n");

  /* Main function */
  fprintf(output, "define i32 @main() {\n");
  fprintf(output, "entry:\n");

  /* Initialize data pointer to center of tape */
  fprintf(output,
          "  %%dp.init = getelementptr inbounds [%d x i8], ptr @cells, i64 0, "
          "i64 %d\n",
          CELL_COUNT * 2, CELL_COUNT);
  fprintf(output, "  %%dp.addr = alloca ptr, align 8\n");
  fprintf(output, "  store ptr %%dp.init, ptr %%dp.addr, align 8\n");
}

static void emit_epilogue(FILE *output) {
  fprintf(output, "  ret i32 0\n");
  fprintf(output, "}\n");
}

/* Load current data pointer value */
static int emit_load_dp(FILE *output) {
  int reg = label_counter++;
  fprintf(output, "  %%t%d = load ptr, ptr %%dp.addr, align 8\n", reg);
  return reg;
}

/* Get pointer to cell at offset from current dp */
static int emit_cell_ptr(FILE *output, int dp_reg, i32 offset) {
  int reg = label_counter++;
  if (offset == 0) {
    fprintf(output, "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 0\n",
            reg, dp_reg);
  } else {
    fprintf(output, "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 %d\n",
            reg, dp_reg, offset);
  }
  return reg;
}

/* Load cell value at pointer */
static int emit_load_cell(FILE *output, int ptr_reg) {
  int reg = label_counter++;
  fprintf(output, "  %%t%d = load i8, ptr %%t%d, align 1\n", reg, ptr_reg);
  return reg;
}

/* Store value to cell */
static void emit_store_cell(FILE *output, int val_reg, int ptr_reg) {
  fprintf(output, "  store i8 %%t%d, ptr %%t%d, align 1\n", val_reg, ptr_reg);
}

void codegen_llvm(const Program *program, FILE *output) {
  label_counter = 0;
  emit_prologue(output);

  for (addr_t i = 0; i < program->size; i++) {
    const Instruction *instr = &program->instructions[i];

    switch (instr->op) {
    case OP_RIGHT: {
      /* dp += distance */
      int dp = emit_load_dp(output);
      int new_dp = label_counter++;
      if (instr->right.distance >= 0) {
        fprintf(output,
                "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 %d\n",
                new_dp, dp, instr->right.distance);
      } else {
        fprintf(output,
                "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 %d\n",
                new_dp, dp, instr->right.distance);
      }
      fprintf(output, "  store ptr %%t%d, ptr %%dp.addr, align 8\n", new_dp);
      break;
    }

    case OP_INC: {
      /* dp[offset] += count */
      int dp = emit_load_dp(output);
      int ptr = emit_cell_ptr(output, dp, instr->inc.offset);
      int val = emit_load_cell(output, ptr);
      int new_val = label_counter++;
      if (instr->inc.count >= 0) {
        fprintf(output, "  %%t%d = add i8 %%t%d, %d\n", new_val, val,
                instr->inc.count);
      } else {
        fprintf(output, "  %%t%d = sub i8 %%t%d, %d\n", new_val, val,
                -instr->inc.count);
      }
      emit_store_cell(output, new_val, ptr);
      break;
    }

    case OP_OUT: {
      /* putchar(dp[offset]) */
      int dp = emit_load_dp(output);
      int ptr = emit_cell_ptr(output, dp, instr->out.offset);
      int val = emit_load_cell(output, ptr);
      int ext = label_counter++;
      fprintf(output, "  %%t%d = zext i8 %%t%d to i32\n", ext, val);
      int call = label_counter++;
      fprintf(output, "  %%t%d = call i32 @putchar(i32 %%t%d)\n", call, ext);
      break;
    }

    case OP_IN: {
      /* dp[offset] = getchar() */
      int dp = emit_load_dp(output);
      int ptr = emit_cell_ptr(output, dp, instr->in.offset);
      int call = label_counter++;
      fprintf(output, "  %%t%d = call i32 @getchar()\n", call);
      int trunc = label_counter++;
      fprintf(output, "  %%t%d = trunc i32 %%t%d to i8\n", trunc, call);
      emit_store_cell(output, trunc, ptr);
      break;
    }

    case OP_LOOP: {
      /* Loop start: check condition and branch */
      int loop_id = i;
      fprintf(output, "  br label %%loop%d_cond\n", loop_id);
      fprintf(output, "\nloop%d_cond:\n", loop_id);

      int dp = emit_load_dp(output);
      int ptr = emit_cell_ptr(output, dp, instr->loop.offset);
      int val = emit_load_cell(output, ptr);
      int cmp = label_counter++;
      fprintf(output, "  %%t%d = icmp eq i8 %%t%d, 0\n", cmp, val);
      fprintf(output, "  br i1 %%t%d, label %%loop%d_end, label %%loop%d_body\n",
              cmp, loop_id, loop_id);
      fprintf(output, "\nloop%d_body:\n", loop_id);
      break;
    }

    case OP_END: {
      /* Loop end: branch back to condition */
      int loop_id = instr->end.match_addr;
      fprintf(output, "  br label %%loop%d_cond\n", loop_id);
      fprintf(output, "\nloop%d_end:\n", loop_id);
      break;
    }

    case OP_SET: {
      /* dp[offset] = value (optionally multiple cells) */
      int dp = emit_load_dp(output);

      if (instr->set.count <= 1) {
        /* Single cell set */
        int ptr = emit_cell_ptr(output, dp, instr->set.offset);
        int val = label_counter++;
        fprintf(output, "  %%t%d = add i8 0, %d\n", val, instr->set.value);
        emit_store_cell(output, val, ptr);
      } else if (instr->set.stride == 0 || instr->set.stride == 1) {
        /* Contiguous memset */
        int ptr = emit_cell_ptr(output, dp, instr->set.offset);
        int call = label_counter++;
        fprintf(output, "  %%t%d = call ptr @memset(ptr %%t%d, i32 %d, i64 %d)\n",
                call, ptr, instr->set.value, instr->set.count);
      } else {
        /* Strided set - use a loop */
        int set_id = label_counter++;
        int ptr = emit_cell_ptr(output, dp, instr->set.offset);
        
        fprintf(output, "  %%stride_ptr%d = alloca ptr, align 8\n", set_id);
        fprintf(output, "  store ptr %%t%d, ptr %%stride_ptr%d, align 8\n", ptr, set_id);
        fprintf(output, "  %%stride_cnt%d = alloca i32, align 4\n", set_id);
        fprintf(output, "  store i32 %d, ptr %%stride_cnt%d, align 4\n", instr->set.count, set_id);
        fprintf(output, "  br label %%stride_loop%d\n", set_id);
        
        fprintf(output, "\nstride_loop%d:\n", set_id);
        int cnt_load = label_counter++;
        fprintf(output, "  %%t%d = load i32, ptr %%stride_cnt%d, align 4\n", cnt_load, set_id);
        int cmp = label_counter++;
        fprintf(output, "  %%t%d = icmp sgt i32 %%t%d, 0\n", cmp, cnt_load);
        fprintf(output, "  br i1 %%t%d, label %%stride_body%d, label %%stride_end%d\n", cmp, set_id, set_id);
        
        fprintf(output, "\nstride_body%d:\n", set_id);
        int cur_ptr = label_counter++;
        fprintf(output, "  %%t%d = load ptr, ptr %%stride_ptr%d, align 8\n", cur_ptr, set_id);
        int val = label_counter++;
        fprintf(output, "  %%t%d = add i8 0, %d\n", val, instr->set.value);
        emit_store_cell(output, val, cur_ptr);
        
        int next_ptr = label_counter++;
        fprintf(output, "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 %d\n",
                next_ptr, cur_ptr, instr->set.stride);
        fprintf(output, "  store ptr %%t%d, ptr %%stride_ptr%d, align 8\n", next_ptr, set_id);
        
        int next_cnt = label_counter++;
        fprintf(output, "  %%t%d = sub i32 %%t%d, 1\n", next_cnt, cnt_load);
        fprintf(output, "  store i32 %%t%d, ptr %%stride_cnt%d, align 4\n", next_cnt, set_id);
        fprintf(output, "  br label %%stride_loop%d\n", set_id);
        
        fprintf(output, "\nstride_end%d:\n", set_id);
      }
      break;
    }

    case OP_SEEK_EMPTY: {
      /* while (dp[offset] != 0) dp += step */
      int seek_id = label_counter++;
      fprintf(output, "  br label %%seek%d_cond\n", seek_id);
      
      fprintf(output, "\nseek%d_cond:\n", seek_id);
      int dp = emit_load_dp(output);
      int ptr = emit_cell_ptr(output, dp, instr->seek.offset);
      int val = emit_load_cell(output, ptr);
      int cmp = label_counter++;
      fprintf(output, "  %%t%d = icmp eq i8 %%t%d, 0\n", cmp, val);
      fprintf(output, "  br i1 %%t%d, label %%seek%d_end, label %%seek%d_body\n",
              cmp, seek_id, seek_id);
      
      fprintf(output, "\nseek%d_body:\n", seek_id);
      int dp2 = emit_load_dp(output);
      int new_dp = label_counter++;
      fprintf(output, "  %%t%d = getelementptr inbounds i8, ptr %%t%d, i64 %d\n",
              new_dp, dp2, instr->seek.step);
      fprintf(output, "  store ptr %%t%d, ptr %%dp.addr, align 8\n", new_dp);
      fprintf(output, "  br label %%seek%d_cond\n", seek_id);
      
      fprintf(output, "\nseek%d_end:\n", seek_id);
      break;
    }

    case OP_TRANSFER: {
      /* Transfer value from source to targets with multiplication */
      int dp = emit_load_dp(output);
      int src_ptr = emit_cell_ptr(output, dp, instr->transfer.src_offset);
      int src_val = emit_load_cell(output, src_ptr);

      if (instr->transfer.is_assignment && instr->transfer.target_count == 1) {
        /* Assignment mode: dst = src * factor + bias */
        const TransferTarget *t = &instr->transfer.targets[0];
        int dst_ptr = emit_cell_ptr(output, dp, t->offset);

        int result;
        if (t->factor == 1) {
          result = src_val;
        } else if (t->factor == -1) {
          result = label_counter++;
          fprintf(output, "  %%t%d = sub i8 0, %%t%d\n", result, src_val);
        } else if (t->factor == 0) {
          result = label_counter++;
          fprintf(output, "  %%t%d = add i8 0, 0\n", result);
        } else {
          int factor_reg = label_counter++;
          fprintf(output, "  %%t%d = add i8 0, %d\n", factor_reg, abs(t->factor));
          result = label_counter++;
          fprintf(output, "  %%t%d = mul i8 %%t%d, %%t%d\n", result, src_val,
                  factor_reg);
          if (t->factor < 0) {
            int neg = label_counter++;
            fprintf(output, "  %%t%d = sub i8 0, %%t%d\n", neg, result);
            result = neg;
          }
        }

        if (t->bias != 0) {
          int biased = label_counter++;
          if (t->bias > 0) {
            fprintf(output, "  %%t%d = add i8 %%t%d, %d\n", biased, result,
                    t->bias);
          } else {
            fprintf(output, "  %%t%d = sub i8 %%t%d, %d\n", biased, result,
                    -t->bias);
          }
          result = biased;
        }

        emit_store_cell(output, result, dst_ptr);
      } else {
        /* Additive mode: dst += src * factor + bias */
        
        /* First apply biases unconditionally */
        for (int t = 0; t < instr->transfer.target_count; t++) {
          const TransferTarget *target = &instr->transfer.targets[t];
          if (target->bias != 0) {
            int dst_ptr = emit_cell_ptr(output, dp, target->offset);
            int dst_val = emit_load_cell(output, dst_ptr);
            int new_val = label_counter++;
            if (target->bias > 0) {
              fprintf(output, "  %%t%d = add i8 %%t%d, %d\n", new_val, dst_val,
                      target->bias);
            } else {
              fprintf(output, "  %%t%d = sub i8 %%t%d, %d\n", new_val, dst_val,
                      -target->bias);
            }
            emit_store_cell(output, new_val, dst_ptr);
          }
        }

        /* Check if source is non-zero before doing transfer */
        int transfer_id = label_counter++;
        int cmp = label_counter++;
        fprintf(output, "  %%t%d = icmp eq i8 %%t%d, 0\n", cmp, src_val);
        fprintf(output,
                "  br i1 %%t%d, label %%transfer_done%d, label %%transfer_do%d\n",
                cmp, transfer_id, transfer_id);

        fprintf(output, "\ntransfer_do%d:\n", transfer_id);

        /* Apply factors */
        for (int t = 0; t < instr->transfer.target_count; t++) {
          const TransferTarget *target = &instr->transfer.targets[t];
          int dst_ptr = emit_cell_ptr(output, dp, target->offset);
          int dst_val = emit_load_cell(output, dst_ptr);

          int scaled;
          if (target->factor == 1) {
            scaled = src_val;
          } else if (target->factor == -1) {
            scaled = label_counter++;
            fprintf(output, "  %%t%d = sub i8 0, %%t%d\n", scaled, src_val);
          } else if (target->factor == 0) {
            /* Factor is 0, skip this target for multiplication */
            continue;
          } else {
            int factor_reg = label_counter++;
            fprintf(output, "  %%t%d = add i8 0, %d\n", factor_reg,
                    abs(target->factor));
            scaled = label_counter++;
            fprintf(output, "  %%t%d = mul i8 %%t%d, %%t%d\n", scaled, src_val,
                    factor_reg);
            if (target->factor < 0) {
              int neg = label_counter++;
              fprintf(output, "  %%t%d = sub i8 0, %%t%d\n", neg, scaled);
              scaled = neg;
            }
          }

          int new_val = label_counter++;
          fprintf(output, "  %%t%d = add i8 %%t%d, %%t%d\n", new_val, dst_val,
                  scaled);
          emit_store_cell(output, new_val, dst_ptr);
        }

        fprintf(output, "  br label %%transfer_done%d\n", transfer_id);
        fprintf(output, "\ntransfer_done%d:\n", transfer_id);
      }
      break;
    }

    case OP_DIV: {
      /* dp[dst] += dp[src] / divisor */
      int dp = emit_load_dp(output);
      int src_ptr = emit_cell_ptr(output, dp, instr->div.src_offset);
      int src_val = emit_load_cell(output, src_ptr);
      int dst_ptr = emit_cell_ptr(output, dp, instr->div.dst_offset);
      int dst_val = emit_load_cell(output, dst_ptr);

      const int shift = get_shift(instr->div.divisor);
      int quot;
      if (shift > 0) {
        /* Use shift for power of 2 */
        quot = label_counter++;
        fprintf(output, "  %%t%d = lshr i8 %%t%d, %d\n", quot, src_val, shift);
      } else {
        /* Use division */
        quot = label_counter++;
        fprintf(output, "  %%t%d = udiv i8 %%t%d, %d\n", quot, src_val,
                instr->div.divisor);
      }

      int new_val = label_counter++;
      fprintf(output, "  %%t%d = add i8 %%t%d, %%t%d\n", new_val, dst_val, quot);
      emit_store_cell(output, new_val, dst_ptr);
      break;
    }

    case OP_MOD: {
      /* dp[dst] = dp[src] % divisor */
      int dp = emit_load_dp(output);
      int src_ptr = emit_cell_ptr(output, dp, instr->mod.src_offset);
      int src_val = emit_load_cell(output, src_ptr);
      int dst_ptr = emit_cell_ptr(output, dp, instr->mod.dst_offset);

      const int shift = get_shift(instr->mod.divisor);
      int rem;
      if (shift > 0) {
        /* Use mask for power of 2 */
        rem = label_counter++;
        fprintf(output, "  %%t%d = and i8 %%t%d, %d\n", rem, src_val,
                instr->mod.divisor - 1);
      } else {
        /* Use modulo */
        rem = label_counter++;
        fprintf(output, "  %%t%d = urem i8 %%t%d, %d\n", rem, src_val,
                instr->mod.divisor);
      }

      emit_store_cell(output, rem, dst_ptr);
      break;
    }

    default:
      fprintf(output, "  ; UNKNOWN OP: %c\n", instr->op);
      break;
    }
  }

  emit_epilogue(output);
}
